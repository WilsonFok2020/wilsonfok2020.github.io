<!DOCTYPE html> <html lang=" en "><head> <meta charset="utf-8"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Gaussian Splatting - Meshes and Beyond | Wilson Fok</title> <meta name="generator" content="Jekyll v3.9.3" /> <meta property="og:title" content="Gaussian Splatting - Meshes and Beyond" /> <meta name="author" content="Wilson Fok" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Application to other domain in Computer Vision The mesh representation is highly versatile and can be manipulated across various applications such as Blender and Unity. However, what determines the mesh quality and the fine, intricate details of the C-arm machine remains unclear to me. To investigate, I varied the raw image resolution during the training of Gaussian Splatting to see if changes in image plane resolution affect the level of detail in the mesh. Since lower-resolution images provide fewer details—averaging more color and light information over a larger grid area—the Gaussian splats also reflect this loss of information. The figures below illustrate this behavior clearly. The image on the left shows a mesh trained with low resolution images (240x134); the right shows a mesh trained with high resolution images (1920x1080) The image on the left shows a mesh trained with low-resolution images (240x134), while the one on the right shows a mesh trained with high-resolution images (1920x1080). By comparing and contrasting these two images (move the slider in the center), we can see that features such as the keyboard, the calibration sheet, the foot pedal of the C-arm, and the sharp edges of various components are richer and more distinctive in the high-resolution mesh. Tips: The Python Open3D (O3D) package offers several useful functions for mesh post-processing. Its visualization features are particularly powerful because they leverage GPU acceleration. Since NumPy functions are highly optimized and the mesh contains many vertices and faces, I avoid Python for-loops and instead rely on NumPy arrays, advanced indexing, and boolean operations to process the mesh as efficiently as possible. import open3d as o3d import numpy as np import os from tqdm import tqdm def crop_mesh_with_radius(mesh_path, output_path, radius): mesh = o3d.io.read_triangle_mesh(mesh_path) vertices = np.asarray(mesh.vertices) print(&quot;reading mesh from&quot;, mesh_path) print(f&quot;Original mesh has {len(vertices)} vertices and {len(mesh.triangles)} triangles.&quot;) # Calculate center of mass center = vertices.mean(axis=0) print(f&quot;Center of mass: {center}&quot;) # Plot original mesh # print(&quot;Plotting original mesh...&quot;) # o3d.visualization.draw_geometries([mesh], window_name=&quot;Original Mesh&quot;) # Distance from center dists = np.linalg.norm(vertices - center, axis=1) kept_indices = np.where(dists &lt;= radius)[0] print(kept_indices, type(kept_indices), kept_indices.shape) # index_map = {int(old_idx): new_idx for new_idx, old_idx in enumerate(kept_indices)} new_vertices = vertices[kept_indices] vertex_mask = np.zeros(vertices.shape[0], dtype=bool) vertex_mask[kept_indices] = True # triangles: (n_triangles, 3) triangles = np.asarray(mesh.triangles) assert len(triangles.shape) ==2 and triangles.shape[1] == 3 # Create a mask for triangles where all vertices are kept triangle_mask = vertex_mask[triangles].all(axis=1) filtered_triangles = triangles[triangle_mask] # Mapping from old to new vertex indices # index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(kept_indices)} # kept_indices: (n_kept,), triangles: (n_triangle, 3) remap_array = np.full(vertices.shape[0], -1, dtype=int) remap_array[kept_indices] = np.arange(len(kept_indices)) filtered_triangles_mapped = remap_array[filtered_triangles] # (n_kept_triangle, 3) # filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles) print(filtered_triangles_mapped, type(filtered_triangles_mapped), filtered_triangles_mapped.shape) # filtered_triangles = [] # for tri in tqdm(triangles): # if set(tri).issubset(index_map.keys()): # filtered_triangles.append([index_map[v] for v in tri]) cropped_mesh = o3d.geometry.TriangleMesh( o3d.utility.Vector3dVector(new_vertices), o3d.utility.Vector3iVector(filtered_triangles_mapped) ) # Transfer vertex colors if they exist if len(mesh.vertex_colors) &gt; 0: old_vertex_colors = np.asarray(mesh.vertex_colors) new_vertex_colors = old_vertex_colors[kept_indices] cropped_mesh.vertex_colors = o3d.utility.Vector3dVector(new_vertex_colors) # Plot mesh after cropping # print(&quot;Plotting cropped mesh...&quot;) # o3d.visualization.draw_geometries([cropped_mesh], window_name=&quot;Cropped Mesh&quot;) o3d.io.write_triangle_mesh(output_path, cropped_mesh) print(f&quot;Cropped mesh saved to {output_path}&quot;) def keep_largest_cluster(mesh_path, output_path): mesh = o3d.io.read_triangle_mesh(mesh_path) print(&quot;reading mesh from&quot;, mesh_path) vertices = np.asarray(mesh.vertices) print(f&quot;Original mesh has {len(vertices)} vertices and {len(mesh.triangles)} triangles.&quot;) with o3d.utility.VerbosityContextManager(o3d.utility.VerbosityLevel.Debug) as cm: triangle_clusters, cluster_n_triangles, cluster_area = ( mesh.cluster_connected_triangles() ) cluster_indices = np.argsort(cluster_n_triangles)[::-1] # Largest first largest_cluster_idx = cluster_indices[0] print(f&quot;Largest cluster index: {largest_cluster_idx}, Size: {cluster_n_triangles[largest_cluster_idx]}&quot;) # Create a mask for triangles belonging to the largest cluster triangle_mask = (triangle_clusters == largest_cluster_idx) filtered_triangles = np.asarray(mesh.triangles)[triangle_mask] # Find unique vertices used in the filtered triangles unique_vertex_indices = np.unique(filtered_triangles) new_vertices = vertices[unique_vertex_indices] # Mapping from old to new vertex indices index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(unique_vertex_indices)} filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles) cropped_mesh = o3d.geometry.TriangleMesh( o3d.utility.Vector3dVector(new_vertices), o3d.utility.Vector3iVector(filtered_triangles_mapped) ) # Transfer vertex colors if they exist if len(mesh.vertex_colors) &gt; 0: old_vertex_colors = np.asarray(mesh.vertex_colors) new_vertex_colors = old_vertex_colors[unique_vertex_indices] cropped_mesh.vertex_colors = o3d.utility.Vector3dVector(new_vertex_colors) cropped_mesh.remove_unreferenced_vertices() cropped_mesh.remove_degenerate_triangles() # Plot mesh after cropping # print(&quot;Plotting cropped mesh...&quot;) # o3d.visualization.draw_geometries([cropped_mesh], window_name=&quot;Cropped Mesh&quot;) o3d.io.write_triangle_mesh(output_path, cropped_mesh) print(f&quot;Cropped mesh saved to {output_path}&quot;) root_dir =r&quot;C:\Users\hp\tableTop\gs\2d-gaussian-splatting\outputs\lifesync\VID_20250725_173235_20_93&quot; for mesh_dir in [1,2,4,8]: mesh_dir = os.path.join(root_dir, &quot;15_&quot; + str(mesh_dir), &quot;train&quot;, &quot;ours_93000&quot;) crop_mesh_with_radius( os.path.join(mesh_dir, &quot;fuse_unbounded.ply&quot;), os.path.join(mesh_dir, &quot;fuse_cropped.ply&quot;), radius=4.5 ) keep_largest_cluster( os.path.join(mesh_dir, &quot;fuse_cropped.ply&quot;), os.path.join(mesh_dir, &quot;fuse_cropped_largest.ply&quot;) ) # break Blender After importing the mesh as a PLY file, Blender allows for extensive editing capabilities. To showcase a compelling lighting effect, I positioned sun light and point light sources near the C-arm model and rendered a video in Blender. The camera was set to follow a circular trajectory, smoothly tracking the target object. Note: Be sure to enable the Geometry Editor and Shader features. Switch on Geometry editor to convert the point cloud to point representation. Assign the color stored as Col (blender is case sensitive) as the color. this color can be saved as a material that is assigned to the geometry Convert point representation to meshes so that the meshes can later be exported to fbx or other preferred file formats. For convenience, Cycles rendering was disabled, and EEVEE was used instead. While the quality is comparable, EEVEE offers significantly faster rendering times. Mobile C-arm Machine Model created by 2D Gaussian Splatting in Blender with lights rendered by EEVEE After further tuning and adjustments, the resulting video better showcases the high-resolution quality of the mesh. Newton famously said he was “standing on the shoulders of giants,” and inspired by that spirit, I integrated output meshes generated by the original 2D Gaussian Splatting research team onto the 2D C-arm model. This highlights how digital assets can be recombined and repurposed in new and creative ways. However, a useful tip is to convert the point cloud to a mesh as the mesh looks more concrete. Below is the procedure to accomplish this with this (DTU) dataset. High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine in ML Orientation High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine and DTU Meshes in Blender Unity Unity is a powerful and widely-used game engine that enables designers to create interactive 2D and 3D experiences. A natural question arises: can our mesh be used as an asset in Unity? Unfortunately Unity does not natively support PLY meshes. Nonetheless, this limitation can be overcome by installing a free unity package to handle ply files. point-cloud-free-viewer. This point could free viewer package successfully imports PLY files as point cloud game object in Unity 6. This point cloud of C-arm machine looks impressive sitting at the corner in this Unity VR example scene. Yet, interactive features such as rigid bodies, mesh colliders, and grab interactions are currently incompatible with pure point cloud objects, as the C-arm lacks a triangular mesh structure. By converting the point cloud to a mesh in Blender, we can export it as an FBX file, which Unity readily imports as a game object. Once imported, adding XR grab interactable components allows the model to respond to physics — for example, falling and breaking under gravity (with gravity set to 9.8 m/s² in Unity). A handy Unity package is called Recorder, which helps me to record play mode / simulation mode into a video file. After further tuning and adjustments, better, prettier, sharper are obtained. Virtual Reality Tutorial Example showing a Gaussian Splatting Pointcloud for a 2D C-arm Machine in Unity Virtual Reality Tutorial Example showing a Gaussian Splatting Meshes become Interactables in Unity Following up next is Gaussian Splatting - Failure, Success, and Lesson Learned Blog posts on this topics Gaussian Splatting - Introduction Gaussian Splatting - Toy Example Gaussian Splatting - Camera Poses Gaussian Splatting - Gaussian Splatting Gaussian Splatting - Meshes and Beyond Gaussian Splatting - Failure, Success, and Lesson Learned" /> <meta property="og:description" content="Application to other domain in Computer Vision The mesh representation is highly versatile and can be manipulated across various applications such as Blender and Unity. However, what determines the mesh quality and the fine, intricate details of the C-arm machine remains unclear to me. To investigate, I varied the raw image resolution during the training of Gaussian Splatting to see if changes in image plane resolution affect the level of detail in the mesh. Since lower-resolution images provide fewer details—averaging more color and light information over a larger grid area—the Gaussian splats also reflect this loss of information. The figures below illustrate this behavior clearly. The image on the left shows a mesh trained with low resolution images (240x134); the right shows a mesh trained with high resolution images (1920x1080) The image on the left shows a mesh trained with low-resolution images (240x134), while the one on the right shows a mesh trained with high-resolution images (1920x1080). By comparing and contrasting these two images (move the slider in the center), we can see that features such as the keyboard, the calibration sheet, the foot pedal of the C-arm, and the sharp edges of various components are richer and more distinctive in the high-resolution mesh. Tips: The Python Open3D (O3D) package offers several useful functions for mesh post-processing. Its visualization features are particularly powerful because they leverage GPU acceleration. Since NumPy functions are highly optimized and the mesh contains many vertices and faces, I avoid Python for-loops and instead rely on NumPy arrays, advanced indexing, and boolean operations to process the mesh as efficiently as possible. import open3d as o3d import numpy as np import os from tqdm import tqdm def crop_mesh_with_radius(mesh_path, output_path, radius): mesh = o3d.io.read_triangle_mesh(mesh_path) vertices = np.asarray(mesh.vertices) print(&quot;reading mesh from&quot;, mesh_path) print(f&quot;Original mesh has {len(vertices)} vertices and {len(mesh.triangles)} triangles.&quot;) # Calculate center of mass center = vertices.mean(axis=0) print(f&quot;Center of mass: {center}&quot;) # Plot original mesh # print(&quot;Plotting original mesh...&quot;) # o3d.visualization.draw_geometries([mesh], window_name=&quot;Original Mesh&quot;) # Distance from center dists = np.linalg.norm(vertices - center, axis=1) kept_indices = np.where(dists &lt;= radius)[0] print(kept_indices, type(kept_indices), kept_indices.shape) # index_map = {int(old_idx): new_idx for new_idx, old_idx in enumerate(kept_indices)} new_vertices = vertices[kept_indices] vertex_mask = np.zeros(vertices.shape[0], dtype=bool) vertex_mask[kept_indices] = True # triangles: (n_triangles, 3) triangles = np.asarray(mesh.triangles) assert len(triangles.shape) ==2 and triangles.shape[1] == 3 # Create a mask for triangles where all vertices are kept triangle_mask = vertex_mask[triangles].all(axis=1) filtered_triangles = triangles[triangle_mask] # Mapping from old to new vertex indices # index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(kept_indices)} # kept_indices: (n_kept,), triangles: (n_triangle, 3) remap_array = np.full(vertices.shape[0], -1, dtype=int) remap_array[kept_indices] = np.arange(len(kept_indices)) filtered_triangles_mapped = remap_array[filtered_triangles] # (n_kept_triangle, 3) # filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles) print(filtered_triangles_mapped, type(filtered_triangles_mapped), filtered_triangles_mapped.shape) # filtered_triangles = [] # for tri in tqdm(triangles): # if set(tri).issubset(index_map.keys()): # filtered_triangles.append([index_map[v] for v in tri]) cropped_mesh = o3d.geometry.TriangleMesh( o3d.utility.Vector3dVector(new_vertices), o3d.utility.Vector3iVector(filtered_triangles_mapped) ) # Transfer vertex colors if they exist if len(mesh.vertex_colors) &gt; 0: old_vertex_colors = np.asarray(mesh.vertex_colors) new_vertex_colors = old_vertex_colors[kept_indices] cropped_mesh.vertex_colors = o3d.utility.Vector3dVector(new_vertex_colors) # Plot mesh after cropping # print(&quot;Plotting cropped mesh...&quot;) # o3d.visualization.draw_geometries([cropped_mesh], window_name=&quot;Cropped Mesh&quot;) o3d.io.write_triangle_mesh(output_path, cropped_mesh) print(f&quot;Cropped mesh saved to {output_path}&quot;) def keep_largest_cluster(mesh_path, output_path): mesh = o3d.io.read_triangle_mesh(mesh_path) print(&quot;reading mesh from&quot;, mesh_path) vertices = np.asarray(mesh.vertices) print(f&quot;Original mesh has {len(vertices)} vertices and {len(mesh.triangles)} triangles.&quot;) with o3d.utility.VerbosityContextManager(o3d.utility.VerbosityLevel.Debug) as cm: triangle_clusters, cluster_n_triangles, cluster_area = ( mesh.cluster_connected_triangles() ) cluster_indices = np.argsort(cluster_n_triangles)[::-1] # Largest first largest_cluster_idx = cluster_indices[0] print(f&quot;Largest cluster index: {largest_cluster_idx}, Size: {cluster_n_triangles[largest_cluster_idx]}&quot;) # Create a mask for triangles belonging to the largest cluster triangle_mask = (triangle_clusters == largest_cluster_idx) filtered_triangles = np.asarray(mesh.triangles)[triangle_mask] # Find unique vertices used in the filtered triangles unique_vertex_indices = np.unique(filtered_triangles) new_vertices = vertices[unique_vertex_indices] # Mapping from old to new vertex indices index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(unique_vertex_indices)} filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles) cropped_mesh = o3d.geometry.TriangleMesh( o3d.utility.Vector3dVector(new_vertices), o3d.utility.Vector3iVector(filtered_triangles_mapped) ) # Transfer vertex colors if they exist if len(mesh.vertex_colors) &gt; 0: old_vertex_colors = np.asarray(mesh.vertex_colors) new_vertex_colors = old_vertex_colors[unique_vertex_indices] cropped_mesh.vertex_colors = o3d.utility.Vector3dVector(new_vertex_colors) cropped_mesh.remove_unreferenced_vertices() cropped_mesh.remove_degenerate_triangles() # Plot mesh after cropping # print(&quot;Plotting cropped mesh...&quot;) # o3d.visualization.draw_geometries([cropped_mesh], window_name=&quot;Cropped Mesh&quot;) o3d.io.write_triangle_mesh(output_path, cropped_mesh) print(f&quot;Cropped mesh saved to {output_path}&quot;) root_dir =r&quot;C:\Users\hp\tableTop\gs\2d-gaussian-splatting\outputs\lifesync\VID_20250725_173235_20_93&quot; for mesh_dir in [1,2,4,8]: mesh_dir = os.path.join(root_dir, &quot;15_&quot; + str(mesh_dir), &quot;train&quot;, &quot;ours_93000&quot;) crop_mesh_with_radius( os.path.join(mesh_dir, &quot;fuse_unbounded.ply&quot;), os.path.join(mesh_dir, &quot;fuse_cropped.ply&quot;), radius=4.5 ) keep_largest_cluster( os.path.join(mesh_dir, &quot;fuse_cropped.ply&quot;), os.path.join(mesh_dir, &quot;fuse_cropped_largest.ply&quot;) ) # break Blender After importing the mesh as a PLY file, Blender allows for extensive editing capabilities. To showcase a compelling lighting effect, I positioned sun light and point light sources near the C-arm model and rendered a video in Blender. The camera was set to follow a circular trajectory, smoothly tracking the target object. Note: Be sure to enable the Geometry Editor and Shader features. Switch on Geometry editor to convert the point cloud to point representation. Assign the color stored as Col (blender is case sensitive) as the color. this color can be saved as a material that is assigned to the geometry Convert point representation to meshes so that the meshes can later be exported to fbx or other preferred file formats. For convenience, Cycles rendering was disabled, and EEVEE was used instead. While the quality is comparable, EEVEE offers significantly faster rendering times. Mobile C-arm Machine Model created by 2D Gaussian Splatting in Blender with lights rendered by EEVEE After further tuning and adjustments, the resulting video better showcases the high-resolution quality of the mesh. Newton famously said he was “standing on the shoulders of giants,” and inspired by that spirit, I integrated output meshes generated by the original 2D Gaussian Splatting research team onto the 2D C-arm model. This highlights how digital assets can be recombined and repurposed in new and creative ways. However, a useful tip is to convert the point cloud to a mesh as the mesh looks more concrete. Below is the procedure to accomplish this with this (DTU) dataset. High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine in ML Orientation High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine and DTU Meshes in Blender Unity Unity is a powerful and widely-used game engine that enables designers to create interactive 2D and 3D experiences. A natural question arises: can our mesh be used as an asset in Unity? Unfortunately Unity does not natively support PLY meshes. Nonetheless, this limitation can be overcome by installing a free unity package to handle ply files. point-cloud-free-viewer. This point could free viewer package successfully imports PLY files as point cloud game object in Unity 6. This point cloud of C-arm machine looks impressive sitting at the corner in this Unity VR example scene. Yet, interactive features such as rigid bodies, mesh colliders, and grab interactions are currently incompatible with pure point cloud objects, as the C-arm lacks a triangular mesh structure. By converting the point cloud to a mesh in Blender, we can export it as an FBX file, which Unity readily imports as a game object. Once imported, adding XR grab interactable components allows the model to respond to physics — for example, falling and breaking under gravity (with gravity set to 9.8 m/s² in Unity). A handy Unity package is called Recorder, which helps me to record play mode / simulation mode into a video file. After further tuning and adjustments, better, prettier, sharper are obtained. Virtual Reality Tutorial Example showing a Gaussian Splatting Pointcloud for a 2D C-arm Machine in Unity Virtual Reality Tutorial Example showing a Gaussian Splatting Meshes become Interactables in Unity Following up next is Gaussian Splatting - Failure, Success, and Lesson Learned Blog posts on this topics Gaussian Splatting - Introduction Gaussian Splatting - Toy Example Gaussian Splatting - Camera Poses Gaussian Splatting - Gaussian Splatting Gaussian Splatting - Meshes and Beyond Gaussian Splatting - Failure, Success, and Lesson Learned" /> <link rel="canonical" href="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" /> <meta property="og:url" content="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" /> <meta property="og:site_name" content="Wilson Fok" /> <meta property="og:image" content="/assets/images/gaussianSplatting/cover.avif" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-08-14T00:00:00+08:00" /> <meta name="twitter:card" content="summary_large_image" /> <meta property="twitter:image" content="/assets/images/gaussianSplatting/cover.avif" /> <meta property="twitter:title" content="Gaussian Splatting - Meshes and Beyond" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wilson Fok"},"dateModified":"2025-08-14T00:00:00+08:00","datePublished":"2025-08-14T00:00:00+08:00","description":"Application to other domain in Computer Vision The mesh representation is highly versatile and can be manipulated across various applications such as Blender and Unity. However, what determines the mesh quality and the fine, intricate details of the C-arm machine remains unclear to me. To investigate, I varied the raw image resolution during the training of Gaussian Splatting to see if changes in image plane resolution affect the level of detail in the mesh. Since lower-resolution images provide fewer details—averaging more color and light information over a larger grid area—the Gaussian splats also reflect this loss of information. The figures below illustrate this behavior clearly. The image on the left shows a mesh trained with low resolution images (240x134); the right shows a mesh trained with high resolution images (1920x1080) The image on the left shows a mesh trained with low-resolution images (240x134), while the one on the right shows a mesh trained with high-resolution images (1920x1080). By comparing and contrasting these two images (move the slider in the center), we can see that features such as the keyboard, the calibration sheet, the foot pedal of the C-arm, and the sharp edges of various components are richer and more distinctive in the high-resolution mesh. Tips: The Python Open3D (O3D) package offers several useful functions for mesh post-processing. Its visualization features are particularly powerful because they leverage GPU acceleration. Since NumPy functions are highly optimized and the mesh contains many vertices and faces, I avoid Python for-loops and instead rely on NumPy arrays, advanced indexing, and boolean operations to process the mesh as efficiently as possible. import open3d as o3d import numpy as np import os from tqdm import tqdm def crop_mesh_with_radius(mesh_path, output_path, radius): mesh = o3d.io.read_triangle_mesh(mesh_path) vertices = np.asarray(mesh.vertices) print(&quot;reading mesh from&quot;, mesh_path) print(f&quot;Original mesh has {len(vertices)} vertices and {len(mesh.triangles)} triangles.&quot;) # Calculate center of mass center = vertices.mean(axis=0) print(f&quot;Center of mass: {center}&quot;) # Plot original mesh # print(&quot;Plotting original mesh...&quot;) # o3d.visualization.draw_geometries([mesh], window_name=&quot;Original Mesh&quot;) # Distance from center dists = np.linalg.norm(vertices - center, axis=1) kept_indices = np.where(dists &lt;= radius)[0] print(kept_indices, type(kept_indices), kept_indices.shape) # index_map = {int(old_idx): new_idx for new_idx, old_idx in enumerate(kept_indices)} new_vertices = vertices[kept_indices] vertex_mask = np.zeros(vertices.shape[0], dtype=bool) vertex_mask[kept_indices] = True # triangles: (n_triangles, 3) triangles = np.asarray(mesh.triangles) assert len(triangles.shape) ==2 and triangles.shape[1] == 3 # Create a mask for triangles where all vertices are kept triangle_mask = vertex_mask[triangles].all(axis=1) filtered_triangles = triangles[triangle_mask] # Mapping from old to new vertex indices # index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(kept_indices)} # kept_indices: (n_kept,), triangles: (n_triangle, 3) remap_array = np.full(vertices.shape[0], -1, dtype=int) remap_array[kept_indices] = np.arange(len(kept_indices)) filtered_triangles_mapped = remap_array[filtered_triangles] # (n_kept_triangle, 3) # filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles) print(filtered_triangles_mapped, type(filtered_triangles_mapped), filtered_triangles_mapped.shape) # filtered_triangles = [] # for tri in tqdm(triangles): # if set(tri).issubset(index_map.keys()): # filtered_triangles.append([index_map[v] for v in tri]) cropped_mesh = o3d.geometry.TriangleMesh( o3d.utility.Vector3dVector(new_vertices), o3d.utility.Vector3iVector(filtered_triangles_mapped) ) # Transfer vertex colors if they exist if len(mesh.vertex_colors) &gt; 0: old_vertex_colors = np.asarray(mesh.vertex_colors) new_vertex_colors = old_vertex_colors[kept_indices] cropped_mesh.vertex_colors = o3d.utility.Vector3dVector(new_vertex_colors) # Plot mesh after cropping # print(&quot;Plotting cropped mesh...&quot;) # o3d.visualization.draw_geometries([cropped_mesh], window_name=&quot;Cropped Mesh&quot;) o3d.io.write_triangle_mesh(output_path, cropped_mesh) print(f&quot;Cropped mesh saved to {output_path}&quot;) def keep_largest_cluster(mesh_path, output_path): mesh = o3d.io.read_triangle_mesh(mesh_path) print(&quot;reading mesh from&quot;, mesh_path) vertices = np.asarray(mesh.vertices) print(f&quot;Original mesh has {len(vertices)} vertices and {len(mesh.triangles)} triangles.&quot;) with o3d.utility.VerbosityContextManager(o3d.utility.VerbosityLevel.Debug) as cm: triangle_clusters, cluster_n_triangles, cluster_area = ( mesh.cluster_connected_triangles() ) cluster_indices = np.argsort(cluster_n_triangles)[::-1] # Largest first largest_cluster_idx = cluster_indices[0] print(f&quot;Largest cluster index: {largest_cluster_idx}, Size: {cluster_n_triangles[largest_cluster_idx]}&quot;) # Create a mask for triangles belonging to the largest cluster triangle_mask = (triangle_clusters == largest_cluster_idx) filtered_triangles = np.asarray(mesh.triangles)[triangle_mask] # Find unique vertices used in the filtered triangles unique_vertex_indices = np.unique(filtered_triangles) new_vertices = vertices[unique_vertex_indices] # Mapping from old to new vertex indices index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(unique_vertex_indices)} filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles) cropped_mesh = o3d.geometry.TriangleMesh( o3d.utility.Vector3dVector(new_vertices), o3d.utility.Vector3iVector(filtered_triangles_mapped) ) # Transfer vertex colors if they exist if len(mesh.vertex_colors) &gt; 0: old_vertex_colors = np.asarray(mesh.vertex_colors) new_vertex_colors = old_vertex_colors[unique_vertex_indices] cropped_mesh.vertex_colors = o3d.utility.Vector3dVector(new_vertex_colors) cropped_mesh.remove_unreferenced_vertices() cropped_mesh.remove_degenerate_triangles() # Plot mesh after cropping # print(&quot;Plotting cropped mesh...&quot;) # o3d.visualization.draw_geometries([cropped_mesh], window_name=&quot;Cropped Mesh&quot;) o3d.io.write_triangle_mesh(output_path, cropped_mesh) print(f&quot;Cropped mesh saved to {output_path}&quot;) root_dir =r&quot;C:\\Users\\hp\\tableTop\\gs\\2d-gaussian-splatting\\outputs\\lifesync\\VID_20250725_173235_20_93&quot; for mesh_dir in [1,2,4,8]: mesh_dir = os.path.join(root_dir, &quot;15_&quot; + str(mesh_dir), &quot;train&quot;, &quot;ours_93000&quot;) crop_mesh_with_radius( os.path.join(mesh_dir, &quot;fuse_unbounded.ply&quot;), os.path.join(mesh_dir, &quot;fuse_cropped.ply&quot;), radius=4.5 ) keep_largest_cluster( os.path.join(mesh_dir, &quot;fuse_cropped.ply&quot;), os.path.join(mesh_dir, &quot;fuse_cropped_largest.ply&quot;) ) # break Blender After importing the mesh as a PLY file, Blender allows for extensive editing capabilities. To showcase a compelling lighting effect, I positioned sun light and point light sources near the C-arm model and rendered a video in Blender. The camera was set to follow a circular trajectory, smoothly tracking the target object. Note: Be sure to enable the Geometry Editor and Shader features. Switch on Geometry editor to convert the point cloud to point representation. Assign the color stored as Col (blender is case sensitive) as the color. this color can be saved as a material that is assigned to the geometry Convert point representation to meshes so that the meshes can later be exported to fbx or other preferred file formats. For convenience, Cycles rendering was disabled, and EEVEE was used instead. While the quality is comparable, EEVEE offers significantly faster rendering times. Mobile C-arm Machine Model created by 2D Gaussian Splatting in Blender with lights rendered by EEVEE After further tuning and adjustments, the resulting video better showcases the high-resolution quality of the mesh. Newton famously said he was “standing on the shoulders of giants,” and inspired by that spirit, I integrated output meshes generated by the original 2D Gaussian Splatting research team onto the 2D C-arm model. This highlights how digital assets can be recombined and repurposed in new and creative ways. However, a useful tip is to convert the point cloud to a mesh as the mesh looks more concrete. Below is the procedure to accomplish this with this (DTU) dataset. High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine in ML Orientation High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine and DTU Meshes in Blender Unity Unity is a powerful and widely-used game engine that enables designers to create interactive 2D and 3D experiences. A natural question arises: can our mesh be used as an asset in Unity? Unfortunately Unity does not natively support PLY meshes. Nonetheless, this limitation can be overcome by installing a free unity package to handle ply files. point-cloud-free-viewer. This point could free viewer package successfully imports PLY files as point cloud game object in Unity 6. This point cloud of C-arm machine looks impressive sitting at the corner in this Unity VR example scene. Yet, interactive features such as rigid bodies, mesh colliders, and grab interactions are currently incompatible with pure point cloud objects, as the C-arm lacks a triangular mesh structure. By converting the point cloud to a mesh in Blender, we can export it as an FBX file, which Unity readily imports as a game object. Once imported, adding XR grab interactable components allows the model to respond to physics — for example, falling and breaking under gravity (with gravity set to 9.8 m/s² in Unity). A handy Unity package is called Recorder, which helps me to record play mode / simulation mode into a video file. After further tuning and adjustments, better, prettier, sharper are obtained. Virtual Reality Tutorial Example showing a Gaussian Splatting Pointcloud for a 2D C-arm Machine in Unity Virtual Reality Tutorial Example showing a Gaussian Splatting Meshes become Interactables in Unity Following up next is Gaussian Splatting - Failure, Success, and Lesson Learned Blog posts on this topics Gaussian Splatting - Introduction Gaussian Splatting - Toy Example Gaussian Splatting - Camera Poses Gaussian Splatting - Gaussian Splatting Gaussian Splatting - Meshes and Beyond Gaussian Splatting - Failure, Success, and Lesson Learned","headline":"Gaussian Splatting - Meshes and Beyond","image":"/assets/images/gaussianSplatting/cover.avif","mainEntityOfPage":{"@type":"WebPage","@id":"/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/"},"url":"/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/"}</script> <!-- End Jekyll SEO tag --> <title>Wilson Fok - A data science enthusiast</title> <meta http-equip="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content="Gaussian Splatting - Meshes and Beyond" /> <meta name="keywords" content="Gaussian Splatting - Meshes and Beyond, Wilson Fok, Deep_Learning" /> <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"> <meta content="" property="fb:app_id"> <meta content="Wilson Fok" property="og:site_name"> <meta content="Gaussian Splatting - Meshes and Beyond" property="og:title"> <meta content="article" property="og:type"> <meta content="This series of articles explores Gaussian Splatting and Neural Radiance Fields (NeRF) for 3D scene reconstruction using C-arm X-ray machine videos. It details capturing video, extracting frames, sparse reconstruction with COLMAP, and training Gaussian Splatting models for real-time, photorealistic 3D rendering. The author shares practical setup challenges, evaluation metrics (SSIM, PSNR, LPIPS), visualization with Splatviz, and mesh extraction for use in Blender and Unity." property="og:description"> <meta content="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" property="og:url"> <meta content="2025-08-14T00:00:00+08:00" property="article:published_time"> <meta content="/about/" property="article:author"> <meta content="/assets/img/posts//assets/images/gaussianSplatting/cover.avif" property="og:image"> <meta content="Deep_Learning" property="article:section"> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@"> <meta name="twitter:creator" content="@"> <meta name="twitter:title" content="Gaussian Splatting - Meshes and Beyond"> <meta content="Wilson Fok" property="og:site_name"> <meta name="twitter:url" content="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/"> <meta name="twitter:description" content="Hello, My name is Wilson Fok. I love to extract useful insights and knowledge from big data. I also like to make new friends and connections. Let's connect! "> <!-- load layout style css --> <link rel="stylesheet" href="/assets/css/main.css" /> <link rel="stylesheet" href="/assets/css/custom-style.css" /> <link rel="stylesheet" href="/assets/bower_components/lightgallery/dist/css/lightgallery.min.css"/> <link rel="stylesheet" href="/assets/bower_components/bootstrap/dist/css/bootstrap.min.css" /> <link rel="stylesheet" href="/assets/bower_components/font-awesome/web-fonts-with-css/css/fontawesome-all.min.css" /> <!-- Favicon --> <link rel="icon" href="/assets/img/favicon.ico" type="image/gif" sizes="16x16"> <!-- Jquery --> <!-- one or more of the below scripts does fancy word animation and dropdown menu --> <script src="/assets/extra_js/jquery-3.4.1.min.js"></script> <script src="/assets/extra_js/picturefill min/picturefill.min.js"></script> <script src="/assets/extra_js/instantsearch min/instantsearch.min.js"></script> <script src="/assets/extra_js/moment min/moment.min.js"></script> <script src="/assets/bower_components/jquery.easing/jquery.easing.min.js"></script> <script src="/assets/bower_components/bootstrap/dist/js/bootstrap.bundle.min.js"></script> <script src="/assets/bower_components/jquery-mousewheel/jquery.mousewheel.min.js"></script> <script src="/assets/bower_components/lightgallery/dist/js/lightgallery-all.min.js"></script> <script src="/assets/bower_components/imagesloaded/imagesloaded.pkgd.min.js"></script> <script src="/assets/bower_components/nanobar/nanobar.min.js"></script> <script src="/assets/bower_components/typewrite/dist/typewrite.min.js"></script> <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> </head><body> <div class="container-fluid"><header> <script src="https://cdn.knightlab.com/libs/juxtapose/latest/js/juxtapose.min.js"></script> <link rel="stylesheet" href="https://cdn.knightlab.com/libs/juxtapose/latest/css/juxtapose.css"> <div class="col-lg-12"> <div class="row"> <nav class="navbar navbar-expand-lg fixed-top navbar-dark " id="topNav"> <!-- <a class="navbar-brand" href="#">Wilson Fok</a> --> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="/">Wilson Fok</a> <div class="collapse navbar-collapse" id="navbarNav"> <ul class="navbar-nav"> <li class="nav-item"> <a class="nav-link" href="/about">About Me</a> </li> <li class="nav-item"> <a class="nav-link" href="/blog">Blog</a> </li> <li class="nav-item"> <a class="nav-link" href="/blog/categories">Categories</a> </li> <li class="nav-item"> <a class="nav-link" href="/gallery">Gallery</a> </li> <li class="nav-item"> <a class="nav-link" href="/contact">Contact Me</a> </li> </ul> </div> <ul class="nav justify-content-end"> <!-- <li class="nav-item"> <a class="nav-link" id="search-icon" href="/search/"><i class="fa fa-search" aria-hidden="true"></i></a> </li> --> <li class="nav-item"> <input class="nav-link switch" id="theme-toggle" onclick="modeSwitcher() "type="checkbox" name="checkbox" > </li> </ul> </nav> </div> </div> </header><div class="col-lg-12"> <!-- Blog Post Breadcrumbs --><div class="col-lg-12"> <nav aria-label="breadcrumb" role="navigation"> <ol class="breadcrumb"> <li class="breadcrumb-item"> <a href="/blog"><i class="fa fa-home" aria-hidden="true"></i></a> </li> <li class="breadcrumb-item active" aria-current="page"><a href="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/">Gaussian Splatting - Meshes and Beyond</a></li> </ol> </nav> </div><div class="row" id="blog-post-container"> <div class="col-lg-8 offset-md-2"><article class="card" itemscope itemtype="http://schema.org/BlogPosting"> <div class="card-header"> <h1 class="post-title" itemprop="name headline">Gaussian Splatting - Meshes and Beyond</h1> <p></p> <h6 class="post-meta"> <i> Summary : This series of articles explores Gaussian Splatting and Neural Radiance Fields (NeRF) for 3D scene reconstruction using C-arm X-ray machine videos. It details capturing video, extracting frames, sparse reconstruction with COLMAP, and training Gaussian Splatting models for real-time, photorealistic 3D rendering. The author shares practical setup challenges, evaluation metrics (SSIM, PSNR, LPIPS), visualization with Splatviz, and mesh extraction for use in Blender and Unity.</i> </h6> <p class="post-summary">Posted by : <img src="/assets/img/profile.png" class="author-profile-img"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"> <span itemprop="name">Wilson Fok</span> </span> on <time datetime="2025-08-14 00:00:00 +0800" itemprop="datePublished">Aug 14, 2025</time> </p> <span class="disqus-comment-count" data-disqus-identifier="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/"></span> <div class="post-categories"> Category : <a href="/blog/categories/Deep_Learning">Deep_Learning</a> </div> </div> <div class="card-body" itemprop="articleBody"> <h1 id="application-to-other-domain-in-computer-vision">Application to other domain in Computer Vision</h1> <p>The mesh representation is highly versatile and can be manipulated across various applications such as Blender and Unity. However, what determines the mesh quality and the fine, intricate details of the C-arm machine remains unclear to me. To investigate, I varied the raw image resolution during the training of Gaussian Splatting to see if changes in image plane resolution affect the level of detail in the mesh.</p> <p>Since lower-resolution images provide fewer details—averaging more color and light information over a larger grid area—the Gaussian splats also reflect this loss of information. The figures below illustrate this behavior clearly.</p> <div class="juxtapose"> <img src="/assets/images/gaussianSplatting/resolutions/240x134.png" /> <img src="/assets/images/gaussianSplatting/resolutions/1920x1080.png" /> </div> <script src="https://cdn.knightlab.com/libs/juxtapose/latest/js/juxtapose.min.js"></script> <link rel="stylesheet" href="https://cdn.knightlab.com/libs/juxtapose/latest/css/juxtapose.css" /> <p>The image on the left shows a mesh trained with low resolution images (240x134); the right shows a mesh trained with high resolution images (1920x1080)</p> <p>The image on the left shows a mesh trained with low-resolution images (240x134), while the one on the right shows a mesh trained with high-resolution images (1920x1080). By comparing and contrasting these two images (move the slider in the center), we can see that features such as the keyboard, the calibration sheet, the foot pedal of the C-arm, and the sharp edges of various components are richer and more distinctive in the high-resolution mesh.</p> <p>Tips: The Python Open3D (O3D) package offers several useful functions for mesh post-processing. Its visualization features are particularly powerful because they leverage GPU acceleration. Since NumPy functions are highly optimized and the mesh contains many vertices and faces, I avoid Python for-loops and instead rely on NumPy arrays, advanced indexing, and boolean operations to process the mesh as efficiently as possible.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">open3d</span> <span class="k">as</span> <span class="n">o3d</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="k">def</span> <span class="nf">crop_mesh_with_radius</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">o3d</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">)</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"reading mesh from"</span><span class="p">,</span> <span class="n">mesh_path</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Original mesh has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s"> vertices and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">)</span><span class="si">}</span><span class="s"> triangles."</span><span class="p">)</span>

    <span class="c1"># Calculate center of mass
</span>    <span class="n">center</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Center of mass: </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Plot original mesh
</span>    <span class="c1"># print("Plotting original mesh...")
</span>    <span class="c1"># o3d.visualization.draw_geometries([mesh], window_name="Original Mesh")
</span>
    <span class="c1"># Distance from center
</span>    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">kept_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">kept_indices</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">kept_indices</span><span class="p">),</span> <span class="n">kept_indices</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># index_map = {int(old_idx): new_idx for new_idx, old_idx in enumerate(kept_indices)}
</span>    <span class="n">new_vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">kept_indices</span><span class="p">]</span>

    <span class="n">vertex_mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vertices</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  
    <span class="n">vertex_mask</span><span class="p">[</span><span class="n">kept_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c1"># triangles: (n_triangles, 3)
</span>    <span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">triangles</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="c1"># Create a mask for triangles where all vertices are kept
</span>    <span class="n">triangle_mask</span> <span class="o">=</span> <span class="n">vertex_mask</span><span class="p">[</span><span class="n">triangles</span><span class="p">].</span><span class="nb">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">filtered_triangles</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[</span><span class="n">triangle_mask</span><span class="p">]</span>

    <span class="c1"># Mapping from old to new vertex indices
</span>    <span class="c1"># index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(kept_indices)}
</span>
    <span class="c1"># kept_indices: (n_kept,), triangles: (n_triangle, 3)
</span>    <span class="n">remap_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="n">vertices</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">remap_array</span><span class="p">[</span><span class="n">kept_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kept_indices</span><span class="p">))</span>
    <span class="n">filtered_triangles_mapped</span> <span class="o">=</span> <span class="n">remap_array</span><span class="p">[</span><span class="n">filtered_triangles</span><span class="p">]</span>  <span class="c1"># (n_kept_triangle, 3)
</span>

    <span class="c1"># filtered_triangles_mapped = np.vectorize(index_map.get)(filtered_triangles)
</span>
    <span class="k">print</span><span class="p">(</span><span class="n">filtered_triangles_mapped</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">filtered_triangles_mapped</span><span class="p">),</span> <span class="n">filtered_triangles_mapped</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    
    <span class="c1"># filtered_triangles = []
</span>    <span class="c1"># for tri in tqdm(triangles):
</span>    <span class="c1">#     if set(tri).issubset(index_map.keys()):
</span>    <span class="c1">#         filtered_triangles.append([index_map[v] for v in tri])
</span>
    <span class="n">cropped_mesh</span> <span class="o">=</span> <span class="n">o3d</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">TriangleMesh</span><span class="p">(</span>
        <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">new_vertices</span><span class="p">),</span>
        <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">Vector3iVector</span><span class="p">(</span><span class="n">filtered_triangles_mapped</span><span class="p">)</span>
    <span class="p">)</span>
    

    <span class="c1"># Transfer vertex colors if they exist
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertex_colors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">old_vertex_colors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertex_colors</span><span class="p">)</span>
        <span class="n">new_vertex_colors</span> <span class="o">=</span> <span class="n">old_vertex_colors</span><span class="p">[</span><span class="n">kept_indices</span><span class="p">]</span>
        <span class="n">cropped_mesh</span><span class="p">.</span><span class="n">vertex_colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">new_vertex_colors</span><span class="p">)</span>


    <span class="c1"># Plot mesh after cropping
</span>    <span class="c1"># print("Plotting cropped mesh...")
</span>    <span class="c1"># o3d.visualization.draw_geometries([cropped_mesh], window_name="Cropped Mesh")
</span>
    <span class="n">o3d</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write_triangle_mesh</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">cropped_mesh</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Cropped mesh saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">keep_largest_cluster</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">,</span> <span class="n">output_path</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">o3d</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"reading mesh from"</span><span class="p">,</span> <span class="n">mesh_path</span><span class="p">)</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Original mesh has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s"> vertices and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">)</span><span class="si">}</span><span class="s"> triangles."</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">VerbosityContextManager</span><span class="p">(</span><span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">VerbosityLevel</span><span class="p">.</span><span class="n">Debug</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
        <span class="n">triangle_clusters</span><span class="p">,</span> <span class="n">cluster_n_triangles</span><span class="p">,</span> <span class="n">cluster_area</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">cluster_connected_triangles</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cluster_n_triangles</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Largest first
</span>        <span class="n">largest_cluster_idx</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Largest cluster index: </span><span class="si">{</span><span class="n">largest_cluster_idx</span><span class="si">}</span><span class="s">, Size: </span><span class="si">{</span><span class="n">cluster_n_triangles</span><span class="p">[</span><span class="n">largest_cluster_idx</span><span class="p">]</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

        <span class="c1"># Create a mask for triangles belonging to the largest cluster
</span>        <span class="n">triangle_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">triangle_clusters</span> <span class="o">==</span> <span class="n">largest_cluster_idx</span><span class="p">)</span>
        <span class="n">filtered_triangles</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">)[</span><span class="n">triangle_mask</span><span class="p">]</span>

        <span class="c1"># Find unique vertices used in the filtered triangles
</span>        <span class="n">unique_vertex_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">filtered_triangles</span><span class="p">)</span>
        <span class="n">new_vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">unique_vertex_indices</span><span class="p">]</span>

        <span class="c1"># Mapping from old to new vertex indices
</span>        <span class="n">index_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">old_idx</span><span class="p">:</span> <span class="n">new_idx</span> <span class="k">for</span> <span class="n">new_idx</span><span class="p">,</span> <span class="n">old_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_vertex_indices</span><span class="p">)}</span>
        <span class="n">filtered_triangles_mapped</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">index_map</span><span class="p">.</span><span class="n">get</span><span class="p">)(</span><span class="n">filtered_triangles</span><span class="p">)</span>

        <span class="n">cropped_mesh</span> <span class="o">=</span> <span class="n">o3d</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">TriangleMesh</span><span class="p">(</span>
            <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">new_vertices</span><span class="p">),</span>
            <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">Vector3iVector</span><span class="p">(</span><span class="n">filtered_triangles_mapped</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Transfer vertex colors if they exist
</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertex_colors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">old_vertex_colors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">vertex_colors</span><span class="p">)</span>
            <span class="n">new_vertex_colors</span> <span class="o">=</span> <span class="n">old_vertex_colors</span><span class="p">[</span><span class="n">unique_vertex_indices</span><span class="p">]</span>
            <span class="n">cropped_mesh</span><span class="p">.</span><span class="n">vertex_colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="p">.</span><span class="n">utility</span><span class="p">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">new_vertex_colors</span><span class="p">)</span>


        <span class="n">cropped_mesh</span><span class="p">.</span><span class="n">remove_unreferenced_vertices</span><span class="p">()</span>
        <span class="n">cropped_mesh</span><span class="p">.</span><span class="n">remove_degenerate_triangles</span><span class="p">()</span>

        <span class="c1"># Plot mesh after cropping
</span>        <span class="c1"># print("Plotting cropped mesh...")
</span>        <span class="c1"># o3d.visualization.draw_geometries([cropped_mesh], window_name="Cropped Mesh")
</span>
        <span class="n">o3d</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write_triangle_mesh</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">cropped_mesh</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Cropped mesh saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>


<span class="n">root_dir</span> <span class="o">=</span><span class="sa">r</span><span class="s">"C:\Users\hp\tableTop\gs\2d-gaussian-splatting\outputs\lifesync\VID_20250725_173235_20_93"</span>
<span class="k">for</span> <span class="n">mesh_dir</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]:</span>
    <span class="n">mesh_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s">"15_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">),</span> <span class="s">"train"</span><span class="p">,</span> <span class="s">"ours_93000"</span><span class="p">)</span>
    <span class="n">crop_mesh_with_radius</span><span class="p">(</span>
        <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">,</span> <span class="s">"fuse_unbounded.ply"</span><span class="p">),</span>
        <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">,</span> <span class="s">"fuse_cropped.ply"</span><span class="p">),</span>
        <span class="n">radius</span><span class="o">=</span><span class="mf">4.5</span>
    <span class="p">)</span>

    <span class="n">keep_largest_cluster</span><span class="p">(</span>
        <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">,</span> <span class="s">"fuse_cropped.ply"</span><span class="p">),</span>
        <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">,</span> <span class="s">"fuse_cropped_largest.ply"</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># break
</span>



</code></pre></div></div> <h3 id="blender">Blender</h3> <p>After importing the mesh as a PLY file, Blender allows for extensive editing capabilities. To showcase a compelling lighting effect, I positioned sun light and point light sources near the C-arm model and rendered a video in Blender. The camera was set to follow a circular trajectory, smoothly tracking the target object.</p> <p>Note: Be sure to enable the Geometry Editor and Shader features.</p> <p>Switch on Geometry editor to convert the point cloud to point representation.</p> <p><img src="/assets/images/gaussianSplatting/geometry.png" style="display: block; margin-left: auto; margin-right: auto; width: 90%;" /></p> <p>Assign the color stored as Col (blender is case sensitive) as the color. this color can be saved as a material that is assigned to the geometry</p> <p><img src="/assets/images/gaussianSplatting/shader.png" style="display: block; margin-left: auto; margin-right: auto; width: 90%;" /></p> <p>Convert point representation to meshes so that the meshes can later be exported to fbx or other preferred file formats.</p> <p><img src="/assets/images/gaussianSplatting/geometryMesh.png" style="display: block; margin-left: auto; margin-right: auto; width: 90%;" /></p> <p>For convenience, Cycles rendering was disabled, and EEVEE was used instead. While the quality is comparable, EEVEE offers significantly faster rendering times.</p> <p><em>Mobile C-arm Machine Model created by 2D Gaussian Splatting in Blender with lights rendered by EEVEE</em></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/bnDNn8VHPwg?si=GdEjrQ04J6_l6Tyk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe> <p>After further tuning and adjustments, the resulting video better showcases the high-resolution quality of the mesh. Newton famously said he was “standing on the shoulders of giants,” and inspired by that spirit, I integrated output meshes generated by the original 2D Gaussian Splatting research team onto the 2D C-arm model. This highlights how digital assets can be recombined and repurposed in new and creative ways.</p> <p><img src="/assets/images/gaussianSplatting/mixScene.png" style="display: block; margin-left: auto; margin-right: auto; width: 90%;" /></p> <p>However, a useful tip is to convert the point cloud to a mesh as the mesh looks more concrete. Below is the procedure to accomplish this with this (DTU) dataset.</p> <p><em>High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine in ML Orientation</em></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/RlMIy31elyc?si=XTtB-nG5deGMJR6Z" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe> <p><em>High Quality and Resolution 2D Gaussian Splatting 2D C-arm Machine and DTU Meshes in Blender</em></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/l43mT6j3ZFc?si=C4wEkI1RaGO8V5HM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe> <h3 id="unity">Unity</h3> <p>Unity is a powerful and widely-used game engine that enables designers to create interactive 2D and 3D experiences. A natural question arises: can our mesh be used as an asset in Unity?</p> <p>Unfortunately Unity does not natively support PLY meshes. Nonetheless, this limitation can be overcome by installing a free unity package to handle ply files. <a href="https://assetstore.unity.com/packages/p/point-cloud-free-viewer-19811">point-cloud-free-viewer</a>. This point could free viewer package successfully imports PLY files as point cloud game object in Unity 6. This point cloud of C-arm machine looks impressive sitting at the corner in this Unity VR example scene.</p> <p>Yet, interactive features such as rigid bodies, mesh colliders, and grab interactions are currently incompatible with pure point cloud objects, as the C-arm lacks a triangular mesh structure.</p> <p><img src="/assets/images/gaussianSplatting/playMode.png" style="display: block; margin-left: auto; margin-right: auto; width: 90%;" /></p> <p><img src="/assets/images/gaussianSplatting/closeUp_playMode.png" style="display: block; margin-left: auto; margin-right: auto; width: 90%;" /></p> <p>By converting the point cloud to a mesh in Blender, we can export it as an FBX file, which Unity readily imports as a game object. Once imported, adding XR grab interactable components allows the model to respond to physics — for example, falling and breaking under gravity (with gravity set to 9.8 m/s² in Unity). A handy Unity package is called Recorder, which helps me to record play mode / simulation mode into a video file. After further tuning and adjustments, better, prettier, sharper are obtained.</p> <p><em>Virtual Reality Tutorial Example showing a Gaussian Splatting Pointcloud for a 2D C-arm Machine in Unity</em></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/sJ_40LogvdM?si=hdTy604rM06lhM-x" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe> <p><em>Virtual Reality Tutorial Example showing a Gaussian Splatting Meshes become Interactables in Unity</em></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/_hOFuMI3sc4?si=CRK0IyikGJgP2l8L" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe> <p>Following up next is <a href="/deep_learning/2025/08/19/GaussianSplatting_failuresAndLessons/">Gaussian Splatting - Failure, Success, and Lesson Learned</a></p> <h1 id="blog-posts-on-this-topics">Blog posts on this topics</h1> <ul> <li><a href="/deep_learning/2025/08/10/GaussianSplatting_introduction/">Gaussian Splatting - Introduction</a></li> <li><a href="/deep_learning/2025/08/11/GaussianSplatting_toyExample/">Gaussian Splatting - Toy Example</a></li> <li><a href="/deep_learning/2025/08/12/GaussianSplatting_camera_poses/">Gaussian Splatting - Camera Poses</a></li> <li><a href="/deep_learning/2025/08/13/GaussianSplatting_gaussianSplatting/">Gaussian Splatting - Gaussian Splatting</a></li> <li><a href="/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/">Gaussian Splatting - Meshes and Beyond</a></li> <li><a href="/deep_learning/2025/08/19/GaussianSplatting_failuresAndLessons/">Gaussian Splatting - Failure, Success, and Lesson Learned</a></li> </ul> </div> <div id="disqus_thread"></div> </article> <article class="card" itemscope itemtype="http://schema.org/BlogPosting"> <div class="card-body" itemprop="articleBody"> <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> <div class="card-header"> <span class="title"> <i class="fa fa-share"></i> Share this to: </span> </div> <div id="share-bar"> <div class="share-buttons"> <a href="https://www.facebook.com/sharer/sharer.php?u=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook" > <i class="fa fa-facebook-official share-button"> facebook</i> </a> <a href="https://twitter.com/intent/tweet?text=Gaussian Splatting - Meshes and Beyond&url=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter" > <i class="fa fa-twitter share-button"> twitter</i> </a> <a href="https://plus.google.com/share?url=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Google+" > <i class="fa fa-google-plus share-button"> google</i> </a> <a href="https://www.pinterest.com/pin/create/button/?url=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Pinterest" > <i class="fa fa-pinterest-p share-button"> pinterest</i> </a> <a href="https://www.tumblr.com/share/link?url=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Tumblr" > <i class="fa fa-tumblr share-button"> tumblr</i> </a> <a href="http://www.reddit.com/submit?url=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Reddit" > <i class="fa fa-reddit-alien share-button"> reddit</i> </a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/&title=Gaussian Splatting - Meshes and Beyond&summary=&source=Wilson Fok" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn" > <i class="fa fa-linkedin share-button"> linkedin</i> </a> <a href="mailto:?subject=Gaussian Splatting - Meshes and Beyond&amp;body=Check out this site /deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/" title="Share via Email" > <i class="fa fa-envelope share-button"> email</i> </a> </div> </div> </div> </article> <script> var disqus_config = function () { this.page.url = "/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond/"; /* Replace PAGE_URL with your page's canonical URL variable */ this.page.identifier = "/deep_learning/2025/08/14/GaussianSplatting_meshesAndBeyond"; /* Replace PAGE_IDENTIFIER with your page's unique identifier variable */ }; (function () { /* DON'T EDIT BELOW THIS LINE */ var d = document, s = d.createElement('script'); s.src = 'https://.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a> </noscript></div> </div> <!-- End of row--> <div class="row"> <div class="col-md-4"> <div class="card"> <div class="card-header"> About </div> <div class="card-body"> <!-- Your Bio --> <p class="author_bio"> Hello, My name is Wilson Fok. I love to extract useful insights and knowledge from big data. Constructive feedback and insightful comments are very welcome!</p> </div> </div> </div> <div class="col-md-4"> <div class="card"> <div class="card-header">Categories </div> <div class="card-body text-dark"> <div id="#Finance"></div> <li class="tag-head"> <a href="/blog/categories/Finance">Finance</a> </li> <a name="Finance"></a> <div id="#NLP"></div> <li class="tag-head"> <a href="/blog/categories/NLP">NLP</a> </li> <a name="NLP"></a> <div id="#Deep_Learning"></div> <li class="tag-head"> <a href="/blog/categories/Deep_Learning">Deep_Learning</a> </li> <a name="Deep_Learning"></a> <div id="#Others"></div> <li class="tag-head"> <a href="/blog/categories/Others">Others</a> </li> <a name="Others"></a> <div id="#Reading"></div> <li class="tag-head"> <a href="/blog/categories/Reading">Reading</a> </li> <a name="Reading"></a> <div id="#Toastmasters"></div> <li class="tag-head"> <a href="/blog/categories/Toastmasters">Toastmasters</a> </li> <a name="Toastmasters"></a> </div> </div> </div> <div class="col-md-4"> <div class="card"> <div class="card-header">Useful Links </div> <div class="card-body text-dark"> <li > <a href="/about">About Me</a> </li> <li > <a href="/blog">Blog</a> </li> <li > <a href="/blog/categories">Categories</a> </li> <li > <a href="/gallery">Gallery</a> </li> <li > <a href="/contact">Contact Me</a> </li> </div> </div> </div> </div> </div> <footer> <p> Powered by Jekyll. Hosted on <a href="https://pages.github.com">Github</a>. Subscribe via <a href=" /feed.xml ">RSS <i class="fa fa-rss" aria-hidden="true"></i> </a> </p> </footer> </div> <script> var options = { classname: 'my-class', id: 'my-id' }; var nanobar = new Nanobar( options ); nanobar.go( 30 ); nanobar.go( 76 ); nanobar.go(100); </script> <!-- <div hidden id="snipcart" data-api-key="Y2I1NTAyNWYtMTNkMy00ODg0LWE4NDItNTZhYzUxNzJkZTI5NjM3MDI4NTUzNzYyMjQ4NzU0"></div> <script src="https://cdn.snipcart.com/themes/v3.0.0-beta.3/default/snipcart.js" defer></script> --> <script src="/assets/js/mode-switcher.js"></script> <script src="/assets/js/slideshow.js"></script> </body> </html>
